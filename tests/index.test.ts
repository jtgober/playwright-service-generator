import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import fs from 'fs';
import path from 'path';

// Mock fs and fetch before importing the module
vi.mock('fs');
const mockFs = vi.mocked(fs);

// Mock fetch globally
global.fetch = vi.fn();

// Import the actual function to test
import { generateServices } from '../src/index.js';

describe('index.ts - Real Function Tests', () => {
  const mockSwaggerSpec = {
    paths: {
      '/v1/users/{id}': {
        get: {
          tags: ['Users'],
          operationId: 'getUserById',
        },
        put: {
          tags: ['Users'],
          operationId: 'updateUser',
        }
      },
      '/v1/products': {
        get: {
          tags: ['Products'],
          operationId: 'getProducts',
        },
        post: {
          tags: ['Products'],
          operationId: 'createProduct',
        }
      },
      '/orders/{orderId}': {
        get: {
          tags: ['Orders'],
          operationId: 'getOrder',
        }
      }
    }
  };

  beforeEach(() => {
    vi.clearAllMocks();
    
    // Mock fs functions
    mockFs.existsSync.mockReturnValue(true);
    mockFs.mkdirSync.mockReturnValue(undefined);
    mockFs.writeFileSync.mockReturnValue(undefined);
    
    // Mock successful fetch
    global.fetch = vi.fn().mockResolvedValue({
      ok: true,
      json: () => Promise.resolve(mockSwaggerSpec),
    } as Response);
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  describe('generateServices function', () => {
    const testOptions = {
      swaggerUrl: 'https://api.example.com/swagger.json',
      outputDir: './test-services'
    };

    it('should fetch swagger spec and generate services', async () => {
      const result = await generateServices(testOptions);

      // Verify fetch was called
      expect(global.fetch).toHaveBeenCalledWith(testOptions.swaggerUrl);

      // Verify services were generated
      expect(result).toContain('UsersService');
      expect(result).toContain('ProductsService');
      expect(result).toContain('OrdersService');

      // Verify files were written
      expect(mockFs.writeFileSync).toHaveBeenCalled();
      
      // Check that service files were created
      const writeFileCalls = mockFs.writeFileSync.mock.calls;
      expect(writeFileCalls.some(call => call[0].toString().includes('UsersService.ts'))).toBe(true);
      expect(writeFileCalls.some(call => call[0].toString().includes('ProductsService.ts'))).toBe(true);
    });

    it('should create output directory if it does not exist', async () => {
      mockFs.existsSync.mockReturnValue(false);

      await generateServices(testOptions);

      expect(mockFs.mkdirSync).toHaveBeenCalledWith(
        path.resolve(process.cwd(), testOptions.outputDir),
        { recursive: true }
      );
    });

    it('should generate correct service file content', async () => {
      await generateServices(testOptions);

      const writeFileCalls = mockFs.writeFileSync.mock.calls;
      const usersServiceCall = writeFileCalls.find(call => 
        call[0].toString().includes('UsersService.ts')
      );

      expect(usersServiceCall).toBeDefined();
      const content = usersServiceCall![1] as string;

      // Check file structure
      expect(content).toContain('// This file was auto-generated by playwright-service-generator');
      expect(content).toContain('import { APIRequestContext } from \'@playwright/test\';');
      expect(content).toContain('export class UsersService {');
      expect(content).toContain('private request: APIRequestContext;');
      expect(content).toContain('constructor(request: APIRequestContext)');
      
      // Check methods are generated
      expect(content).toContain('async getUserById(id)');
      expect(content).toContain('async updateUser(id, data?: any)');
      expect(content).toContain('this.request.get');
      expect(content).toContain('this.request.put');
    });

    it('should handle routes without leading slashes correctly', async () => {
      await generateServices(testOptions);

      const writeFileCalls = mockFs.writeFileSync.mock.calls;
      const usersServiceCall = writeFileCalls.find(call => 
        call[0].toString().includes('UsersService.ts')
      );

      const content = usersServiceCall![1] as string;
      
      // Routes should not have leading slashes
      expect(content).toContain('v1/users/${id}');
      expect(content).not.toContain('/v1/users/${id}');
    });

    it('should include data parameter for POST/PUT/PATCH methods', async () => {
      await generateServices(testOptions);

      const writeFileCalls = mockFs.writeFileSync.mock.calls;
      const productsServiceCall = writeFileCalls.find(call => 
        call[0].toString().includes('ProductsService.ts')
      );

      const content = productsServiceCall![1] as string;
      
      // POST method should have data parameter
      expect(content).toContain('createProduct(data?: any)');
      expect(content).toContain('this.request.post(`v1/products`, { data })');
      
      // GET method should not have data parameter
      expect(content).toContain('getProducts()');
      expect(content).toContain('this.request.get(`v1/products`)');
    });

    it('should handle swagger fetch errors', async () => {
      global.fetch = vi.fn().mockResolvedValue({
        ok: false,
        statusText: 'Not Found',
      } as Response);

      await expect(generateServices(testOptions))
        .rejects
        .toThrow('Failed to fetch Swagger spec: Not Found');
    });

    it('should handle network errors', async () => {
      global.fetch = vi.fn().mockRejectedValue(new Error('Network error'));

      await expect(generateServices(testOptions))
        .rejects
        .toThrow('Network error');
    });

    it('should group endpoints by tags correctly', async () => {
      const result = await generateServices(testOptions);

      // Should have separate services for each tag
      expect(result).toHaveLength(3); // Users, Products, Orders
      expect(result).toContain('UsersService');
      expect(result).toContain('ProductsService');
      expect(result).toContain('OrdersService');
    });

    it('should handle endpoints without tags using Default', async () => {
      const swaggerWithoutTags = {
        paths: {
          '/status': {
            get: {
              operationId: 'getStatus',
            }
          }
        }
      };

      global.fetch = vi.fn().mockResolvedValue({
        ok: true,
        json: () => Promise.resolve(swaggerWithoutTags),
      } as Response);

      const result = await generateServices(testOptions);

      expect(result).toContain('DefaultService');
    });

    it('should handle multiple endpoints in same service', async () => {
      await generateServices(testOptions);

      const writeFileCalls = mockFs.writeFileSync.mock.calls;
      const usersServiceCall = writeFileCalls.find(call => 
        call[0].toString().includes('UsersService.ts')
      );

      const content = usersServiceCall![1] as string;
      
      // Should have multiple methods for Users service
      expect(content).toContain('async getUserById');
      expect(content).toContain('async updateUser');
    });
  });

  describe('Query Parameter Support', () => {
    const mockSwaggerWithQueryParams = {
      paths: {
        '/v1/users': {
          get: {
            tags: ['Users'],
            operationId: 'getUsers',
            parameters: [
              {
                name: 'searchString',
                in: 'query',
                required: false,
                schema: { type: 'string' }
              },
              {
                name: 'limit',
                in: 'query',
                required: true,
                schema: { type: 'integer' }
              }
            ]
          }
        },
        '/v2/orders': {
          get: {
            tags: ['Orders'],
            operationId: 'getOrders',
            parameters: [
              {
                name: 'statusCode',
                in: 'query',
                required: true,
                schema: { type: 'string' }
              },
              {
                name: 'beginDate',
                in: 'query',
                required: true,
                schema: { type: 'string' }
              },
              {
                name: 'endDate',
                in: 'query',
                required: false,
                schema: { type: 'string' }
              }
            ]
          }
        },
        '/v1/products/{id}': {
          get: {
            tags: ['Products'],
            operationId: 'getProductById',
            parameters: [
              {
                name: 'id',
                in: 'path',
                required: true,
                schema: { type: 'string' }
              },
              {
                name: 'includeDetails',
                in: 'query',
                required: false,
                schema: { type: 'string' }
              }
            ]
          }
        }
      }
    };

    beforeEach(() => {
      vi.clearAllMocks();
      mockFs.existsSync.mockReturnValue(true);
      mockFs.mkdirSync.mockReturnValue(undefined);
      mockFs.writeFileSync.mockReturnValue(undefined);
      
      global.fetch = vi.fn().mockResolvedValue({
        ok: true,
        json: () => Promise.resolve(mockSwaggerWithQueryParams),
      } as Response);
    });

    it('should extract query parameters from swagger spec', async () => {
      const testOptions = {
        swaggerUrl: 'https://api.example.com/swagger.json',
        outputDir: './test-services'
      };

      await generateServices(testOptions);

      const writeFileCalls = mockFs.writeFileSync.mock.calls;
      const usersServiceCall = writeFileCalls.find(call => 
        call[0].toString().includes('UsersService.ts')
      );

      expect(usersServiceCall).toBeDefined();
      const content = usersServiceCall![1] as string;

      // Should include query parameters in method signature
      expect(content).toContain('getUsers(searchString?: string, limit: number)');
      
      // Should generate clean query string in URL
      expect(content).toContain('v1/users?searchString=${searchString}&limit=${limit}');
    });

    it('should handle required and optional query parameters correctly', async () => {
      const testOptions = {
        swaggerUrl: 'https://api.example.com/swagger.json',
        outputDir: './test-services'
      };

      await generateServices(testOptions);

      const writeFileCalls = mockFs.writeFileSync.mock.calls;
      const ordersServiceCall = writeFileCalls.find(call => 
        call[0].toString().includes('OrdersService.ts')
      );

      expect(ordersServiceCall).toBeDefined();
      const content = ordersServiceCall![1] as string;

      // Required parameters should not have ? in signature
      expect(content).toContain('getOrders(statusCode: string, beginDate: string, endDate?: string)');
      
      // Should generate query string with all parameters
      expect(content).toContain('v2/orders?statusCode=${statusCode}&beginDate=${beginDate}&endDate=${endDate}');
    });

    it('should handle path parameters and query parameters together', async () => {
      const testOptions = {
        swaggerUrl: 'https://api.example.com/swagger.json',
        outputDir: './test-services'
      };

      await generateServices(testOptions);

      const writeFileCalls = mockFs.writeFileSync.mock.calls;
      const productsServiceCall = writeFileCalls.find(call => 
        call[0].toString().includes('ProductsService.ts')
      );

      expect(productsServiceCall).toBeDefined();
      const content = productsServiceCall![1] as string;

      // Should have path param first, then query params
      expect(content).toContain('getProductById(id, includeDetails?: string)');
      
      // Should generate URL with both path and query parameters
      expect(content).toContain('v1/products/${id}?includeDetails=${includeDetails}');
    });

    it('should handle integer query parameters with correct TypeScript types', async () => {
      const testOptions = {
        swaggerUrl: 'https://api.example.com/swagger.json',
        outputDir: './test-services'
      };

      await generateServices(testOptions);

      const writeFileCalls = mockFs.writeFileSync.mock.calls;
      const usersServiceCall = writeFileCalls.find(call => 
        call[0].toString().includes('UsersService.ts')
      );

      expect(usersServiceCall).toBeDefined();
      const content = usersServiceCall![1] as string;

      // Integer query param should be typed as number
      expect(content).toContain('limit: number');
      expect(content).not.toContain('limit: string');
    });

    it('should handle endpoints without query parameters (regression test)', async () => {
      const swaggerWithoutQueryParams = {
        paths: {
          '/v1/status': {
            get: {
              tags: ['Status'],
              operationId: 'getStatus',
              parameters: [] // No parameters
            }
          }
        }
      };

      global.fetch = vi.fn().mockResolvedValue({
        ok: true,
        json: () => Promise.resolve(swaggerWithoutQueryParams),
      } as Response);

      const testOptions = {
        swaggerUrl: 'https://api.example.com/swagger.json',
        outputDir: './test-services'
      };

      await generateServices(testOptions);

      const writeFileCalls = mockFs.writeFileSync.mock.calls;
      const statusServiceCall = writeFileCalls.find(call => 
        call[0].toString().includes('StatusService.ts')
      );

      expect(statusServiceCall).toBeDefined();
      const content = statusServiceCall![1] as string;

      // Should not have query parameters
      expect(content).toContain('getStatus()');
      expect(content).toContain('v1/status`');
      expect(content).not.toContain('?');
    });

    it('should handle POST/PUT methods with both query parameters and data', async () => {
      const swaggerWithPostQueryParams = {
        paths: {
          '/v1/users': {
            post: {
              tags: ['Users'],
              operationId: 'createUser',
              parameters: [
                {
                  name: 'notify',
                  in: 'query',
                  required: false,
                  schema: { type: 'string' }
                }
              ]
            }
          }
        }
      };

      global.fetch = vi.fn().mockResolvedValue({
        ok: true,
        json: () => Promise.resolve(swaggerWithPostQueryParams),
      } as Response);

      const testOptions = {
        swaggerUrl: 'https://api.example.com/swagger.json',
        outputDir: './test-services'
      };

      await generateServices(testOptions);

      const writeFileCalls = mockFs.writeFileSync.mock.calls;
      const usersServiceCall = writeFileCalls.find(call => 
        call[0].toString().includes('UsersService.ts')
      );

      expect(usersServiceCall).toBeDefined();
      const content = usersServiceCall![1] as string;

      // Should have query params before data parameter
      expect(content).toContain('createUser(notify?: string, data?: any)');
      
      // Should include both query string and data in request
      expect(content).toContain('v1/users?notify=${notify}`, { data }');
    });

    it('should filter out non-query parameters', async () => {
      const swaggerWithMixedParams = {
        paths: {
          '/v1/users/{id}': {
            get: {
              tags: ['Users'],
              operationId: 'getUserById',
              parameters: [
                {
                  name: 'id',
                  in: 'path',
                  required: true,
                  schema: { type: 'string' }
                },
                {
                  name: 'Authorization',
                  in: 'header',
                  required: true,
                  schema: { type: 'string' }
                },
                {
                  name: 'expand',
                  in: 'query',
                  required: false,
                  schema: { type: 'string' }
                }
              ]
            }
          }
        }
      };

      global.fetch = vi.fn().mockResolvedValue({
        ok: true,
        json: () => Promise.resolve(swaggerWithMixedParams),
      } as Response);

      const testOptions = {
        swaggerUrl: 'https://api.example.com/swagger.json',
        outputDir: './test-services'
      };

      await generateServices(testOptions);

      const writeFileCalls = mockFs.writeFileSync.mock.calls;
      const usersServiceCall = writeFileCalls.find(call => 
        call[0].toString().includes('UsersService.ts')
      );

      expect(usersServiceCall).toBeDefined();
      const content = usersServiceCall![1] as string;

      // Should only include path param and query param, not header param
      expect(content).toContain('getUserById(id, expand?: string)');
      expect(content).not.toContain('Authorization');
      
      // Should generate URL with path and query params only
      expect(content).toContain('v1/users/${id}?expand=${expand}');
    });
  });
});
