import fs from 'fs';
import path from 'path';
import { toCamelCase } from './method-naming.js';

export const generateBaseFile = (services: string[], testsDir: string, outputDir: string, merge: boolean = false) => {
    const outputPath = path.resolve(process.cwd(), testsDir);
    if (!fs.existsSync(outputPath)) fs.mkdirSync(outputPath, { recursive: true });

    // Calculate relative path from tests directory to services directory
    const testsAbsolutePath = path.resolve(process.cwd(), testsDir);
    const servicesAbsolutePath = path.resolve(process.cwd(), outputDir);
    const relativePath = path.relative(testsAbsolutePath, servicesAbsolutePath).replace(/\\/g, '/');

    const baseFilePath = path.join(outputPath, 'base.ts');
    let existingServices: string[] = [];
    let existingImports: Map<string, string> = new Map(); // service name -> import path

    // Check if base.ts already exists and extract existing services (only if merge is true)
    if (merge && fs.existsSync(baseFilePath)) {
        const existingContent = fs.readFileSync(baseFilePath, 'utf8');
        // Extract import statements with their paths
        const importMatches = existingContent.matchAll(/import\s+{\s*(\w+)\s*}\s+from\s+['"`]([^'"`]+)\.js['"`];/g);
        for (const match of importMatches) {
            if (match[1] && match[2]) {
                existingServices.push(match[1]);
                existingImports.set(match[1], match[2]);
            }
        }
    }

    // Merge new services with existing ones (remove duplicates) if merge is true, otherwise use only new services
    const allServices = merge ? [...new Set([...existingServices, ...services])] : services;

    let imports = `// This file was auto-generated by playwright-service-generator

import { test as base } from '@playwright/test';\n`;
    
    // Generate imports - use existing paths for existing services, new path for new services
    imports += allServices.map(s => {
        const importPath = existingImports.has(s) ? existingImports.get(s) : `${relativePath}/${s}`;
        return `import { ${s} } from '${importPath}.js';`;
    }).join('\n') + '\n\n';

    let fixturesType = `type MyFixtures = {\n`;
    fixturesType += allServices.map(s => `  ${toCamelCase(s)}: ${s};`).join('\n');
    fixturesType += `\n};\n\n`;

    let extendBlock = `export const test = base.extend<MyFixtures>({\n`;
    extendBlock += allServices.map(s =>
        `  ${toCamelCase(s)}: async ({ request }, use) => {\n    const service = new ${s}(request);\n    await use(service);\n  }`
    ).join(',\n');
    extendBlock += `\n});\n\n`;

    extendBlock += `export { expect } from '@playwright/test';\n`;

    const content = imports + fixturesType + extendBlock;
    fs.writeFileSync(baseFilePath, content, 'utf8');
}

export const generateSkeletonTest = (testsDir: string) => {
    const outputPath = path.resolve(process.cwd(), testsDir);
    if (!fs.existsSync(outputPath)) fs.mkdirSync(outputPath, { recursive: true });

    const content = `// This file was auto-generated by playwright-service-generator

import { test, expect } from './base';

test('Creating and updating a person should be successful', { tag: ['@smoke'] }, async ({ request }) => {
  // Start creating tests here 
  expect(true).toBe(true);
});
`;

    fs.writeFileSync(path.join(outputPath, 'skeleton-test.ts'), content, 'utf8');
}
